모듈화
    - Modularity는 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록
      시스템의 기능들을 모듈 단위로 나누는 것을 의미한다.
    - 모듈화는 결합도의 최소화와 모듈 내 요소들의 응집도를 최대화 하는 것이 목표이다.

추상화
    - Abstraction은 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것이다.
    - 유형
        ㄱ. 과정 추상화 - 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법.
        ㄴ. 자료 추상화 - 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법.
        ㄷ. 제어 추상화 - 이벤트 발생의 정확한 절차나 방법을 정의 하지 않고, 대표할 수 있는 표현으로 대체하는 방법.

정보은닉
    - Information Hiding은 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 
      다른 모듈이 접근하거나 변경하지 못하도록 하는 기겁

협약에 의한 설계
    - 선행조건: 오퍼레이션이 호출되기 전에 참이 되어야할 조건
    - 결과조건: 오퍼레이션이 수행된 후 만족되어야할 조건
    - 불변조건: 오퍼레이션이 실행되는 동안 항상 만족되어야할 조건

파이프-필터 패턴(Pipe-Filter Pattern)
    - 데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴
    - 데이터 변환, 버퍼링, 동기화 등에 주료 사용
    - 대표적으로 UNIX의 쉘(Shell)이 있음.

마스터-슬레이브 패턴(Master-Slave Pattern)
    - 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로
      작업을 수행하는 패턴
    - 장애 허용 시스템, 벙렬 컴퓨터 시스템

브로커 패턴
    - 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가
      요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴

피어-투-피어 패턴(Peer-To-Peer Pattern)
    - 피어(Peer)라 불리는 하나의 컴포넌트가 클라이언트가/서버가 될수도 있는 패턴

이벤트-버스 패턴(Event-Bus Pattern)
    - 소스가 특정채널에 이벤트 메시지를 발행(Publish)하면, 해당 채널을
      구독(Subscribe)한 리스너(Listener)들이 메시지를 받아 이벤트를 처리하는 패턴

블랙보드 패턴(Blackboard Pattern)
    - 모든 컴포넌트들이 공유 데이터 저장소/블랙보드 컴포넌트에 접근이 가능한 패턴

인터프리터 패턴(Interpreter Pattern)
    - 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성하는 패턴

클래스
    - 공통된 속성과 연산을 갖는 객체들의 집합
    - 클래스에 속한 각각의 객체를 인스턴스(Instance)라 한다.

메시지
    - Message는 객체들 간의 상호작용에 사용되는 수단으로,
      객체ㅢ 동작이나 연산을 일으키는 외부의 요구사항

캡슐화
    - Encapsulation은 외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉

객체지향 분석
    - OOA; Object Oriented Analysis는 사용자의 요구사항과 관련된
      객체, 속성, 연산, 관계 등을 정의하여 모델링 하는 작업

객체지양 분석 방법론
    - Rumbaugh(럼바우) 방법: 분석활동을 객체모델, 동적모델, 기능모델로 나누어 수행
    - Booch(부치) 방법: 미시적/거시적 개발 프로세스를 모두 사용하여 클래스/객체들을 분석 및 식별하고 연산을 정의
    - Jacobson 방법: 유스케이스를 강조하여 사용
    - Coad /Ypurdon 방법: E-R다이어그램을 사용하여 객체의 행위를 모델링
    - Wirfs-Brock 방법: 분석과 설계간의 구분이 없고, 고객 명세서를 평가하여 설계 작업까지 연속적으로 수행

럼바우의 분석 기법
    - 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링 하는 기법

SOLID 원칙
    - 단일책임원칙(SRP): 객체는 단 하나의 책임만 가져야함
    - 개방-폐쇄원칙(OCP): 기존 코드를 변경하지 않고, 기능을 추가할 수 있도록 설계
    - 리스코프 치환 원칙(LSP): 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다는 원칙
    - 인터페이스 분리 원칙(ISP): 자신이 사용하지 않는 인터페이스와 의존관계를 맺거나 영향을 받지 않아야 한다는 원칙
    - 의존 역전 원칙(DIP): 의존 관계 성립 시 추상성이 높은 클래스와 의존관계를 맺어야 한다는 원칙

모듈
    - 모듈화를 통해 분리된 시스템의 각 기능

결합도
    - 모듈 간에 상호 의존하는 정도 또는 두 모듈사이의 연관 관계

    결합도의 종류와 강도
    내용 > 공통 > 외부 > 제어 > 스탬프 > 자료

    ㄱ.내용결합도 - 한 모듈이 다른 모듈의 내부 기능 및 내부 자료를 직접 참조하거나 수정할 때 결합도
    ㄴ.공통결합도 - 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때 결합도
    ㄷ.외부결합도 - 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때 결합도
    ㄹ.제어결합도 - 어떤 모듈이 다른 모듈 내부의 논리적 흐름을 제어하기 위해 제어 신호/제어요소를 전달하는 결합도
    ㅁ.스탬프결합도 - 모듈 간의 인터페이스로 배열/레코드 등의 자료구조가 전달될 때 결합도
    ㅂ.자료결합도 - 모듈 간의 인터페이스가 자료 요소로 구성될 때 결합도

응집도
    - 모듈의 내부 요소들이 서로 관련되어 있는 정도

    응집도의 종류와 강도
    기능적 > 순차적 > 교환적 > 절차적 > 시간적 > 논리적 > 우연적

    ㄱ.기능적 응짐도 - 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우 응집도
    ㄴ.순차적 응짐도 - 모듈 내 하나의 활동으로부터 나온 출력데이터를 그 다음 활동의 데이터로 사용할 경우의 응집도
    ㄷ.교환적 응집도 - 동일한 입/출력을 사용하여 서로 다른 기능을 수행하는 구성요소이 모엿을 경우 응집도
    ㄹ.절차적 응집도 - 모듈이 다수의 관련 기능을 순차적으로 수행할 경우의 응집도
    ㅁ.시간적 응집도 - 특정 시간에 몇개의 기능을 모아 하나의 모듈로 작성할 경우 응집도
    ㅂ.논리적 응짐도 - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우 응집도
    ㅅ.우연적 응짐도 - 모듈 내부의 각 구성요소들이 서로 관련 없는 요소들로만 구성된 경우의 응집도

팬인 / 팬아웃
    - Fan-In은 어떤 모듈을 제어하는 모듈의 수
    - Fan-Out은 어떤 모듈에 의해 제어되는 모듈의 수를 의미

N-S 차트
    - 논리의 기술에 중점을 두고 도형을 이용해 표현
    - GOTO / 화살표를 사용하지 않음

IPC(Inter-Process Communcation)
    - 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
    - 공유메모리 / 소켓 / 세마포어 / 파이프 & 네임드 파이퍼 / 메시지 큐잉

테스트케이스
    - 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서

재사용
    - 이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화 하는 작업

순차코드
    - 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를
      부여하는 방법으로, 순서 코드 또는 일련번호 코드라고도 한다.

블록코드
    - 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고,
      각 블록 내에서 일련번호를 부여하는 방법으로, 구분코드라고도 한다.

10진 코드(Decimal Code)
    - 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을
      필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 한다.

그룹 분류 코드(Group Classification Code)
    - 코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고
      각 그룹 안에서 일련번호를 부여하는 방법

연상 코드(Mnemonic Code)
    - 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법

표의 숫자 코드(Significant Digit Code)
    - 코드화 대상 항목의 물리적 수치를 그대로 코드에 적용시키는 방법으로, 유효 숫자 코드라고도 함.

합성 코드(Combined Code)
    - 필요한 기능을 하나의 코드로 수행하기 어려운 경우 코드를 조합하여 만드는 방법

디자인패턴
    - 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미.

    [생성(Creational) 패턴]
    - 객체 생성 과정을 추상화하여 유연하고 재사용 가능한 객체 생성을 지원

    1. Singleton      : 하나의 인스턴스만 생성하여 전역적으로 사용
    2. Factory Method : 객체 생성을 서브클래스에 위임
    3. Abstract Factory : 관련 객체들을 그룹으로 생성
    4. Builder        : 복잡한 객체를 단계별로 생성
    5. Prototype      : 기존 객체를 복사(clone)해서 생성

    [구조(Structural) 패턴]
    - 클래스나 객체를 조합하여 더 큰 구조를 만들되, 유연성과 확장성을 유지

    1. Adapter        : 인터페이스 호환 안 되는 클래스끼리 연결
    2. Bridge         : 구현과 추상을 분리하여 독립적으로 확장
    3. Composite      : 트리 구조 표현, 전체와 부분을 동일하게 처리
    4. Decorator      : 객체에 기능을 동적으로 추가
    5. Facade         : 복잡한 서브시스템에 단순 인터페이스 제공
    6. Flyweight      : 공유를 통해 메모리 절약
    7. Proxy          : 대리 객체를 통해 접근 제어

    [행위(Behavioral) 패턴]
    - 객체 간의 책임 분산과 상호작용을 정의

    1. Chain of Responsibility : 요청을 처리할 수 있는 객체에게 순차 전달
    2. Command        : 요청을 객체로 캡슐화하여 실행 취소/재실행 지원
    3. Interpreter    : 문법 규칙을 클래스로 표현하고 해석
    4. Iterator       : 컬렉션 순회 방법을 캡슐화
    5. Mediator       : 객체 간 직접 통신 대신 중재자 객체 사용
    6. Memento        : 객체 상태 저장 및 복원
    7. Observer       : 한 객체 상태 변화 → 의존 객체들에게 알림
    8. State          : 상태에 따라 객체 행동 변경
    9. Strategy       : 알고리즘을 캡슐화하여 교체 가능
    10. Template Method : 알고리즘 뼈대를 정의하고, 세부는 하위 클래스에 위임
    11. Visitor       : 구조 변경 없이 기능 추가 가능

