다음 설명에 해당하는 디자인 패턴을 <보기>에서 찾으시오.

자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴이다.
내부 표현 방법의 노출 없이 순차적인 접근이 가능하다.

생성                        구조            행위
Abstract Factory        Adaptor         Command
Builder                 Bridge          Interpreter
Factory Method          Composite       Iterator
Prototype               Decorator       Mediator
Singleton               Proxy           Observer

답: Iterator

[생성 패턴]

1. Abstract Factory
- 관련된 객체들을 팩토리 계열로 묶어서 생성
- 구체 클래스에 의존하지 않고 제품군을 생성
- 예: GUI 라이브러리에서 Mac, Windows 스타일을 바꾸는 팩토리

2. Builder
- 복잡한 객체를 단계별로 생성
- 동일한 생성 과정으로 서로 다른 표현 생성 가능
- 예: HTML 문서 빌더, 자동차 빌더

3. Factory Method
- 객체 생성을 서브클래스에 위임
- 상위 클래스는 객체 생성 인터페이스만 제공
- 예: Document를 만드는 Application 클래스

4. Prototype
- 기존 객체를 복사하여 새 객체 생성
- 객체 생성 비용이 클 때 유용
- 예: 게임 캐릭터 복제, 서식 복사

5. Singleton
- 애플리케이션 전체에서 단 하나만 존재하는 인스턴스 보장
- 전역 접근 지점 제공
- 예: DB 연결, 환경 설정 관리자


[구조 패턴]

1. Adaptor
- 호환되지 않는 인터페이스를 연결
- 클래스나 객체의 인터페이스를 다른 인터페이스로 변환
- 예: 110V → 220V 변환 어댑터

2. Bridge
- 구현과 추상을 분리하여 독립적으로 확장 가능
- 상속 대신 위임 구조를 사용
- 예: 다양한 형태의 리모컨과 TV 연결

3. Composite
- 트리 구조로 객체 구성 (부분-전체 계층 구조)
- 단일 객체와 복합 객체를 동일하게 처리
- 예: 폴더-파일 구조, UI 컴포넌트

4. Decorator
- 객체에 동적으로 기능 추가
- 상속 없이 기능 확장 가능
- 예: 커피에 우유, 시럽, 휘핑크림 추가

5. Proxy
- 실제 객체에 대한 대리 객체 제공
- 접근 제어, 로깅, 지연 로딩 등에 사용
- 예: 가상 프록시, 보호 프록시, 스마트 참조


[행위 패턴]

1. Command
- 요청을 객체로 캡슐화
- 실행 취소, 작업 큐 등에 유용
- 예: 리모컨의 버튼 명령, 실행 취소/재실행

2. Interpreter
- 문법 규칙을 객체로 표현하여 해석기 구현
- 간단한 언어나 표현식 해석에 사용
- 예: 계산기, 정규표현식 해석기

3. Iterator
- 컬렉션을 순차적으로 접근하는 인터페이스 제공
- 내부 구현을 노출하지 않음
- 예: Java의 Iterator, Python의 for-each

4. Mediator
- 객체들 간의 상호작용을 중앙에서 중재
- 클래스 간의 직접 통신 제거, 복잡도 감소
- 예: 채팅방에서 서버가 중재 역할 수행

5. Observer
- 객체 상태 변화 시, 관련 객체에 알림 전파
- 일대다 의존 관계
- 예: 게시판 알림, 이벤트 리스너, MVC의 View 갱신
